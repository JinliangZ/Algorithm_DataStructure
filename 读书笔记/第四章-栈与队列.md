### 第四章-栈与队列

###### 4.2 栈的定义

- 4.2.1 栈的定义

  > 栈（stack）是限定仅在 表尾 进行 插入和删除 操作的 线性表。

  我们把允许插入和删除的一端称为栈顶（top），另一段称为栈底（bottom），不含任何数据元素的栈称为空栈。
  栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。

  栈元素具有线性关系，即前驱后继关系。定义中的表尾是指栈顶，而不是栈底。

- 4.2.2 进栈出栈变化形式
  栈对线性表的插入和删除位置进行了限制，并没有对元素进出的时间进行限制。

###### 4.3 栈的抽象数据类型

DATA 同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。

Operation：push，pop 等。

###### 4.4 栈的顺序存储结构及实现

- 4.4.1 栈的顺序存储结构
  数组下标为 0 的一端作为栈底比较好。
  若存储栈的长度为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定为 top 等于-1.

- 4.4.2 栈的顺序存储结构 ——进栈操作
- 4.4.3 栈的顺序存储结构 ——出栈操作

> 两者没有涉及到任何循环语句，因此时间复杂度均是*O(1)*。

###### 4.5 两栈共享空间

用一个数组存两个具有相同数据类型的栈。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为数组的末端，即下标为数组长度 n-1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。

两个指针之间相差 1 时，即 top1+1 = top2 为栈满。

###### 4.6 栈的链式存储结构及实现

- 4.6.1 栈的链式存储结构（简称链栈）
  把栈顶放在单链表的头部。
- 4.6.2 栈的链式存储结构 ——进栈操作
- 4.6.3 栈的链式存储结构 ——出栈操作

> 链栈的 push 和 pop 操作都很简单，没有任何循环操作，时间复杂度均为*O(1)*。

对比顺序栈和链栈。

###### 4.7 栈的作用

栈的引入简化了程序设计的问题。所以现在的许多高级语言，比如 Java 等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，非常方便。

###### 4.8 栈的应用 ——递归

栈有一个很重要的应用：在程序设计语言中实现了递归。

- 4.8.1 斐波那契数列实现
  递归：函数自己调用自己。

- 4.8.2 递归定义
  我们把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称做递归函数。
  写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

  这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构。

###### 4.9 栈的应用 ——四则运算表达式求值

- 4.9.1 后缀（逆波兰）表示法定义
  逆波兰（Reverse Polish Notation）表示。

- 4.9.2 后缀表达式计算结果
  规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

- 4.9.3 中缀表达式转后缀表达式
  规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号 或者 优先级低于栈顶符号（乘除优先加减），则栈顶元素依次全部出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

让计算机处理中缀表达式，最重要的就是两步：

1. 将中缀表达式转化为后缀表达式（栈用来进出运算的符号）；
2. 将后缀表达式进行运算得出结果（栈用来进出运算的数字）。

###### 4.10 队列的定义

> 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

###### 4.11 队列的抽象数据类型

队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。

DATA 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。

Operation 出队列（队头），入队列（队尾）

###### 4.12 循环队列

- 4.12.1 队列顺序存储的不足
  入队列操作，时间复杂度为*O(1)*。
  出队列的时间复杂度为*O(n)*。出队列的实现和线性表的顺序存储结构完全相同。

  > 为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。

  会产生“假溢出”的现象。

- 4.12.2 循环队列定义
  解决”假溢出“的办法就是后面满了，就从头开始，也就是头尾相接的循环。
  我们把队列的这种头尾相接的顺序存储结构称为循环队列。
  空队列时，front = rear, 满队列时，front = rear，两种办法判断队列究竟是空还是满。

单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题。

###### 4.13 队列的链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。

- 4.13.1 队列的链式存储结构 ——入队操作
- 4.13.2 队列的链式存储结构 ——出队操作

循环队列和链队列从时间上，其实它们的基本操作都是常数时间，即都为*O(1)*。
在空间上，链队列更加灵活。
总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。

###### 4.14 总结回顾

栈和队列都是特殊的线性表，只不过对插入和删除操作做了限制。
它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端：

- 对于两个相同数据类型的栈，可以用两栈共享空间的方法。
- 对于两个相同数据类型的队列，可以使用循环队列。

### 第六章-树

###### 6.2 树的定义

> 树（Tree）是 n（n >= 0）个结点的有限集。 n=0 时称为空树。在任意一颗非空树中：
> （1）有且仅有一个特定的称为根（Root）的结点；
> （2）当 n>1 时，其余结点可分为 m（m>0）个互不相交的有限集 T1、T2、......、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

树的定义其实就是我们在讲解栈时，提到的递归的方法。也就是在树的定义之中还用到了树的概念。

对于树的定义还需强调两点：

1. n>0 时根结点是唯一的。
2. m>0 时，子树的个数没有限制，但它们一定是互不相交的。

- 6.2.1 结点分类
  结点拥有的子树数称为结点的度（Degree）。
  度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或者分支结点。
  树的度是树内各结点的度的最大值。
- 6.2.2 结点间关系
  结点的子树的根结点称为该结点的 Child，相应地，该结点称为 Child 的 Parent。
  同一个 Parent 之间互称 Sibling。
- 6.2.3 树的其他相关概念
  结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。
  树中结点的最大层次称为树的深度（Depth）或高度。
  如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。
  森林（Forest）是 m（m>=0）棵互不相交的树的集合。

###### 6.3 树的抽象数据类型

DATA 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation 很多

###### 6.4 树的存储结构

- 6.4.1 双亲表示法
  树除了根结点外，其余每个结点，有且仅有一个双亲。
  假设以一组连续空间存储树的结点，每个结点中，data 是数据域，存储结点的数据信息。而 parent 是指针域，存储该结点的双亲在数组中的下标。
  由于根结点是没有双亲的，所以我们约定根结点的指针域设置为 -1。

  我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为*O(1)*，直到 parent 为-1 时，表示找到了树的根结点。可我们要想知道结点的孩子是什么，需要遍历整个结构才行。

  改进：

  1. 增加一个结点最左边孩子的域，叫它长子域，如果没有孩子的结点，长子域设置为-1。
  2. 增加一个右兄弟域来体现兄弟关系，每个结点如果存在右兄弟，则记录右兄弟的下标，如果不存在，则赋值为-1。

- 6.4.2 孩子表示法

  - 由于树中每个结点可能有多棵子树，可以考虑用多重链表，即

    > 每个结点有多个指针域，其中每个指针指向一个子树的根结点，这种方法叫做多重链表表示法。

    根据树的每个结点的度不同，设计两种解决方案：

    1. 指针域的个数就等于树的度，即树中各个结点度的最大值。各结点的度相差很大时，浪费空间。
    2. 每个结点指针域的个数等于该结点的度，并且专门取一个位置来存储结点指针域的个数。提高了空间利用率，但是由于各个结点的链表是不同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。

  - 既减少空指针的浪费，又能使结点结构相同。把每个结点放到一个顺序存储结构的数组中，再对每个结点的孩子建立一个单链表体现它们的关系。

    > 孩子表示法： 把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

    为此设计两种结点结构：

    1. 孩子链表的孩子结点： child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。
    2. 表头数组的表头结点：data 是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。

    这样的结构，查找某个结点的某个孩子，或某个结点的兄弟，只需要查找这个结点的孩子单链表即可。
    对于遍历整棵树也很方便，对头结点的数组循环即可。

    若要知道某个结点的双亲是谁：结合孩子表示法和双亲表示法，称为双亲孩子表示法，算是孩子表示法的改进。

- 6.4.3 孩子兄弟表示法
  任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。
  data 是数据域，firstchild 是指针域，存储该结点第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。
  这种表示方法，给查找某个结点的某个孩子带来了方便，只需要通过 firtchild 找到此结点的长子，然后再通过长子结点的 rightsib 找到它的二弟，接着一直下去，直到找到具体的孩子。

  > 这个表示法的最大好处是它把一颗复杂的树变成了一颗二叉树。

###### 6.5 二叉树的定义

> 二叉树（Binary Tree）是 n（n>=0）个结点的有限集合，该集合或为空集（称为空二叉树），或由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

- 6.5.1 二叉树的特点

  1. 每个结点最多有两个子树。
  2. 左子树和右子树是有顺序的。次序不能任意颠倒。
  3. 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

  二叉树具有五种基本形态：

  1. 空二叉树
  2. 只有一个根结点
  3. 根结点只有左子树
  4. 根结点只有右子树
  5. 根结点既有左子树也有右子树

- 6.5.2 特殊二叉树
  1. 斜树
     所有的结点都只有左子树的二叉树叫左斜树，所有的结点都只有右子树的二叉树叫右斜树，统称为斜树。
  2. 满二叉树
     在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的二叉树称为满二叉树。
  3. 完全二叉树
     对一颗具有 n 个结点的二叉树*按层序编号*，如果编号为 i（1 <= i <=n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。
     关键词：”按层序编号“
     完全二叉树的特点：
     1. 叶子结点只能出现在最下两层
     2. 最下层的叶子结点一定集中在左部连续位置
     3. 倒数第二层，若有叶子结点，一定都在右部连续位置
     4. 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况
     5. 同样结点数的二叉树，完全二叉树的深度最小。

###### 6.6 二叉树的性质

- 6.6.1 二叉树性质 1
  > 在二叉树的第 i 层上至多有 2^i-1^个结点（i>=1）。
- 6.6.2 二叉树性质 2
  > 深度为 k 的二叉树至多有 2^k^-1 个结点（i>=1）。
- 6.6.3 二叉树性质 3

  > 对任何一颗二叉树 T，如果其终端结点数为 n~0~，度为 2 的结点数为 n~2~,则 n~0~= n~2~+1.

- 6.6.4 二叉树性质 4
  > 具有 n 个结点的*完全二叉树*的深度为[log~2~n]+1（[x]表示不大于 x 的最大整数）。
- 6.6.5 二叉树性质 5
  > 如果对一棵有 n 个结点的完全二叉树（其深度为[log~2~n]+1）的结点按层序编号（从第 1 层到第[log~2~n]+1 层，每层从左到右），对任一结点 i（1 <= i <= n）有：
  1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点[i/2]。
  2. 如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。
  3. 如果 2i+1 >n, 则结点 i 无右孩子；否则其右孩子是结点 2i+1。

###### 6.7 二叉树的存储结构

- 6.7.1 二叉树顺序存储结构
  二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标能体现结点之间的逻辑关系。
  完全二叉树的顺序存储：将完全二叉树存入到数组中，相应的下标对应其同样的层序编号。
  对于一般的二叉树：尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，把不存在的结点设置为" ^ "。
  这样，右斜树会造成对存储空间的极大浪费，所以顺序存储结构一般只用于完全二叉树。

- 6.7.2 二叉链表

  > 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样的链表叫做二叉链表。
  > data 是数据域，lchild 是左孩子的指针域，rchild 是右孩子的指针域。

  如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。

###### 6.8 遍历二叉树

- 6.8.1 二叉树遍历原理

  > 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种*次序*依次访问二叉树中所有结点，使得每个结点*被访问*且*仅被访问一次*。

- 6.8.2 二叉树遍历方法
  二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：

  1. 前序遍历：根结点 -> 左子树 -> 右子树
     规则是 若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，在前序遍历右子树。
  2. 中序遍历：左子树 -> 根结点 -> 右子树
     规则是 若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。
  3. 后序遍历： 左子树 -> 右子树 -> 根结点
     规则是 若树为空，则空操作返回，否则从左到右，先叶子后结点的方式，遍历访问左右子树，最后是访问根结点。
  4. 层序遍历：按层次遍历
     规则是 若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序，对结点逐个访问。

  对于计算机来说，它只有循环、判断等方式来处理，它只会处理线性序列，而这四种遍历方法，其实都是把树中的结点变成某种意义的线性序列。

- 6.8.3 前序遍历算法 PreOrderTraverse
  二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁。

  ```
  void PreOrderTraverse(BiTree T)
  {
    if(T == null)
      return;
    printf("%c", T->data); 显示结点数据，可以更改为其他对结点的操作
    PreOrderTraverse(T->lchild); 再前序遍历左子树
    PreOrderTraverse(T->rchild); 最后前序遍历右子树
  }
  ```

- 6.8.4 中序遍历算法 InOrderTraverse
  它和前序遍历算法仅仅只是代码的顺序上的差异。

  ```
  void InOrderTraverse(BiTree T)
  {
    if(T == null)
      return;
    InOrderTraverse(T->lchild); 先中序遍历左子树
    printf("%c", T->data); 显示结点数据，可以更改为其他对结点的操作
    InOrderTraverse(T->rchild); 最后中序遍历右子树
  }
  ```

- 6.8.5 后序遍历算法

  ```
  void PostOrderTraverse(BiTree T)
  {
    if(T == null)
      return;
    PostOrderTraverse(T->lchild); 先后序遍历左子树
    PostOrderTraverse(T->rchild); 再后序遍历右子树
    printf("%c", T->data); 显示结点数据，可以更改为其他对结点的操作

  }
  ```

- 6.8.6 推导遍历结果
  已知一棵二叉树的前序遍历序列为 ABCDEF,中序遍历为 CBAEDF，问这颗二叉树的后序遍历结果是多少？
  前序遍历可知：A 为根结点
  中序遍历可知： CB 为左子树的结点，EDF 是右子树的结点
  前序遍历可知：B 是 A 的孩子，C 是 B 孩子，但 C 是 B 左孩子和右孩子还不可能确定
  中序遍历可知：C 是在 B 的前面打印的，C 是 B 的左孩子
  前序遍历可知：D 是 A 的右孩子，E 和 F 是 D 的子孙，它们中又一个不一定是孩子，还可能是孙子
  中序遍历可知：E 是 D 的左孩子，F 是 D 的右孩子
  后序遍历是：CBEFDA

  > 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
  > 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
  > 已知前序和后序遍历序列，是不能确定一棵二叉树的。

###### 6.9 二叉树的建立

将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树可以做到*一个遍历序列*确定一棵二叉树。

###### 6.10 线索二叉树

- 6.10.1 线索二叉树原理
  一方面，对于一个有 n 个结点的二叉链表，每个结点有指向左右孩子的两个指针域，一共是 2n 个指针域。而 n 个结点的二叉树共有 n-1 条分支线， 也就是说，存在 2n - (n-1) = n+1 个空指针域。白白浪费内存的资源。
  另一方面，对二叉树遍历过后，通过序列就知道某个结点的前驱和后继是谁。

  在二叉链表上，我们只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱和后继是谁。
  考虑利用那些空指针域，存放指向某个结点在某种遍历次序下的前驱和后继结点的地址。

  > 我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。

  把二叉树进行中序遍历后，将所有的空指针域中的 rchild，改为指向它的后继结点。再将所有空指针域中的 lchild，改为指向当前结点的前驱。

  其实线索二叉树，等于把一棵二叉树转变成了一个双向链表，这样对我们的插入，删除，结点，查找某个结点都带了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。

  我们在每个结点再增设两个标志域 ltag 和 rtag，只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像 lchild 和 rchild 的指针变量。

  > 结点结构 ： lchild ltag data rtag rchild
  > ltag 为 0 时，指向该结点的左孩子；为 1 时，指向该结点的前驱。
  > rtag 为 0 时，指向该结点的右孩子；为 1 时，指向该结点的后继。

- 6.10.2 线索二叉树结构实现
  由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。
  时间复杂度为*O(n)*。
  所在的实际问题中，如果所用的二叉树需经常遍历或查找结点时，需要某种遍历序列中的前驱和后继，采用线索二叉链表的存储结构就是非常不错的选择。

###### 6.11 树、森林与二叉树的转换
